name: Auto Release (PR)

on:
  pull_request:
    types: [closed]
    branches: [main]

jobs:
  prepare-release:
    if: github.event.pull_request.merged == true && contains(github.event.pull_request.labels.*.name, 'release')
    runs-on: ubuntu-latest
    permissions:
      contents: write
    environment: release-approval

    outputs:
      new_version: ${{ steps.new_version.outputs.new }}
      version_type: ${{ steps.version_type.outputs.type }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: Setup Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Determine version type from PR
        id: version_type
        run: |
          PR_TITLE="${{ github.event.pull_request.title }}"
          PR_LABELS="${{ join(github.event.pull_request.labels.*.name, ' ') }}"

          # Determine version type based on PR labels or title
          if echo "$PR_LABELS" | grep -q "major\|breaking"; then
            echo "type=major" >> $GITHUB_OUTPUT
          elif echo "$PR_LABELS" | grep -q "minor\|feature"; then
            echo "type=minor" >> $GITHUB_OUTPUT
          else
            echo "type=patch" >> $GITHUB_OUTPUT
          fi

      - name: Get current version
        id: current_version
        run: |
          if [ -f "version.json" ]; then
            VERSION=$(grep -o '"version"[[:space:]]*:[[:space:]]*"[^"]*"' version.json | cut -d'"' -f4)
          elif [ -f "Cargo.toml" ]; then
            VERSION=$(grep '^version = ' Cargo.toml | head -1 | cut -d'"' -f2)
          else
            VERSION="0.0.0"
          fi
          echo "current=$VERSION" >> $GITHUB_OUTPUT

      - name: Calculate new version
        id: new_version
        run: |
          CURRENT="${{ steps.current_version.outputs.current }}"
          TYPE="${{ steps.version_type.outputs.type }}"

          IFS='.' read -r major minor patch <<< "$CURRENT"

          case $TYPE in
            "major")
              major=$((major + 1))
              minor=0
              patch=0
              ;;
            "minor")
              minor=$((minor + 1))
              patch=0
              ;;
            "patch")
              patch=$((patch + 1))
              ;;
          esac

          NEW_VERSION="$major.$minor.$patch"
          echo "new=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "ðŸš€ Preparing to release version $NEW_VERSION (type: $TYPE)"

      - name: Display release information
        run: |
          echo "## ðŸ“‹ Release Information" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Current Version:** ${{ steps.current_version.outputs.current }}" >> $GITHUB_STEP_SUMMARY
          echo "**New Version:** ${{ steps.new_version.outputs.new }}" >> $GITHUB_STEP_SUMMARY
          echo "**Version Type:** ${{ steps.version_type.outputs.type }}" >> $GITHUB_STEP_SUMMARY
          echo "**PR Title:** ${{ github.event.pull_request.title }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âš ï¸ **Please review the version information above before approving this deployment.**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "After approval, the following will happen:" >> $GITHUB_STEP_SUMMARY
          echo "1. Version files will be updated" >> $GITHUB_STEP_SUMMARY
          echo "2. Git tag v${{ steps.new_version.outputs.new }} will be created" >> $GITHUB_STEP_SUMMARY
          echo "3. Release workflow will be triggered automatically" >> $GITHUB_STEP_SUMMARY

  execute-release:
    needs: prepare-release
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: Setup Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Update version files
        run: |
          NEW_VERSION="${{ needs.prepare-release.outputs.new_version }}"
          CURRENT_DATE=$(date +"%Y-%m-%d")

          echo "Updating version to $NEW_VERSION..."

          # Update version files (same logic as manual release)
          if [ -f "version.json" ]; then
            sed -i "s/\"version\"[[:space:]]*:[[:space:]]*\"[^\"]*\"/\"version\": \"$NEW_VERSION\"/" version.json
            sed -i "s/\"build_date\"[[:space:]]*:[[:space:]]*\"[^\"]*\"/\"build_date\": \"$CURRENT_DATE\"/" version.json
            echo "Updated version.json"
          fi

          if [ -f "Cargo.toml" ]; then
            sed -i "s/^version = \"[^\"]*\"/version = \"$NEW_VERSION\"/" Cargo.toml
            echo "Updated Cargo.toml"
          fi

          if [ -f "package.json" ]; then
            sed -i "s/\"version\"[[:space:]]*:[[:space:]]*\"[^\"]*\"/\"version\": \"$NEW_VERSION\"/" package.json
            echo "Updated package.json"
          fi

          if [ -f "tauri.conf.json" ]; then
            sed -i "s/\"version\"[[:space:]]*:[[:space:]]*\"[^\"]*\"/\"version\": \"$NEW_VERSION\"/" tauri.conf.json
            echo "Updated tauri.conf.json"
          fi

      - name: Commit and create tag
        run: |
          NEW_VERSION="${{ needs.prepare-release.outputs.new_version }}"

          # Commit version updates
          git add .
          git commit -m "release: Release $NEW_VERSION"

          # Create tag
          git tag -a "v$NEW_VERSION" -m "Release $NEW_VERSION"

          # Push changes and tag
          git push origin main
          git push origin "v$NEW_VERSION"

          echo "âœ… Released version v$NEW_VERSION"
          echo "ðŸš€ GitHub Actions will automatically build and publish the release"
